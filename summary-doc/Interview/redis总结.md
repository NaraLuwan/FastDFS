## redis数据结构
string、list、set、zset、hash、hyperloglog、bitmap、geo

## redis常用命令
keys [正则] 查询所有的键，会遍历所有的键值，复杂度O(n) -> scan 它可以有效的解决keys命令存在的阻塞问题，scan每次的额复杂度是O(1)
dbsize 查询键总数，直接获取redis内置的键总数变量，复杂度O(1)
exists key 存在返回1，不存在返回0
type key 如果键hello是字符串类型，则返回string；如果键不存在，则返回none
select dbIndex 切换数据库，默认16个数据库：0-15，进入redis后默认是0库。不建议使用多个数据库
flushdb / flushall 用于清除数据库，flushdb只清除当前数据库，flushall清除所有数据库

事务：
1. multi 标记一个事务块的开始
2. exec 执行事务块内的命令
3. discard 取消执行事务块内的所有命令
Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。
事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

ping 测试与服务器的连接，如果正常则返回pong
bgsave/save 后台异步/同步保存数据到硬盘
info 查看服务器统计信息，如：内存使用情况

## redis和memcached区别
memcached只支持简单的key/value数据结构，redis更丰富
memcached无法持久化（数据备份、恢复），原生不支持集群部署
memcached多线程模型，redis单线程，基于非阻塞io多路复用技术

## redis单线程为什么这么快
Redis Server本身是多线程的，除了请求处理流程是单线程处理之外，Redis内部还有其他工作线程在后台执行，它负责异步执行某些比较耗时的任务，例如AOF每秒刷盘、AOF文件重写都是在另一个线程中完成的。
- 纯内存操作：读写操作都在内存中完成，内部构建了一个哈希表，指定KEY访问只需要O(1)的时间复杂度
- 使用IO多路复用技术：非阻塞+IO多路复用技术的事件驱动模型，由操作系统实现提供，使得redis可以在单线程中监听多个Socket的请求，在任意一个Socket可读/可写时，Redis去读取客户端请求，在内存中操作对应的数据，然后再写回到Socket中。
- 非CPU密集型任务：Redis作者提到，由于Redis的大部分操作并不是CPU密集型任务，而Redis的瓶颈在于内存和网络带宽。
- 单线程的优势：没有了多线程上下文切换的性能损耗，没有了访问共享资源加锁的性能损耗

在使用Redis时，一定要避免非常耗时的操作，例如：操作大key数据，一次性获取过多的数据、大量key集中过期等，这些场景都会阻塞住整个处理线程，直到它们处理完成，势必会影响业务的访问。

## redis缓存策略：定期删除 + 惰性删除 + 内存淘汰策略
定期删除：规定一定时间内定期的扫描一遍 expires 字典，将已过期的键删除掉。这种方法解决了定时删除的耗费资源的问题，但是该种方法不能保证所有的 key 过期删除。
例如：key1 生存时间是 3s, 而定期删除的时间间隔是 5s, 那这个 key 在 3 秒后还存在内存中，并没有被删除。
惰性删除：在获取每一个 key 的时候，判断一下该 key 是否已经过了过期时间，如果已经失效，则删除掉这个 key。惰性删除的缺点也很明显，如果一个 key 一直不使用，则即使到了过期时间也会一直占有内存，大量的不使用的 key 会使得内存暴增。

即使采用了 定期删除+惰性删除 的策略，还是不能保证所有的过期 key 都被删除。这种情况下，还是会导致内存占用率增高。解决办法：启用内存淘汰策略
内存淘汰策略：Redis 每执行一个命令，就会判断当前占用的内存是否大于设置的最大内存，大于，则开始内存淘汰机制。

Redis 内存淘汰的机制有以下几种方案可供选择：
- volatile-lru：从设置过期的数据集中淘汰最少使用的 key
- volatile-ttl：从设置过期的数据集中淘汰即将过期的 key
- volatile-random：从设置过期的数据集中随机选取 key 淘汰
- allkeys-lru：从所有的数据集中选取最少使用的数据
- allkyes-random：从所有的数据集中任意选取数据淘汰
- no-envicition：不进行淘汰

## redis主从复制

默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。
需要注意，主从复制的开启，完全是在从节点发起的；不需要我们在主节点做任何事情。

主从复制的作用主要包括：

数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。
高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。

## hyperloglog原理
基于伯努利试验（抛硬币无论抛了多少次，只要出现了正面就记为一次实验），对于一个输入的字符串，首先得到64位的hash值，用前14位来定位桶的位置（共有2的14次方即16384个桶），后面50位即为伯努利过程，每个桶有6bit，记录第一次出现1的位置count，如果count>oldcount，就用count替换oldcount，
最终所有桶估计值的调和平均数就是估计基数值，每次调用pfcount的时候会先读取hyperloglog对象头结构体中的基数缓存（也有过期时间）